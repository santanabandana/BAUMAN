#include <iostream>
#include <ctime>
#include <clocale>
#include <chrono>
using namespace std;

void bubblesort(int* l, int* r) {  
    int sz = r - l;
    if (sz <= 1) return;
    bool b = true;
    while (b) {
        b = false;
        for (int* i = l; i + 1 < r; i++) {
            if (*i > * (i + 1)) {
                swap(*i, *(i + 1));
                b = true;
            }
        }
        r--;
    }
}

void quicksort(int* l, int* r) { 
    if (r - l <= 1) return;
    int z = *(l + (r - l) / 2);
    int* ll = l, * rr = r - 1;
    while (ll <= rr) {
        while (*ll < z) ll++;
        while (*rr > z) rr--;
        if (ll <= rr) {
            swap(*ll, *rr);
            ll++;
            rr--;
        }
    }
    if (l < rr) quicksort(l, rr + 1);
    if (ll < r) quicksort(ll, r);
}

int main()
{
    setlocale(LC_ALL, "Russian");
    cout << "Введите размер массива: " << endl;
    int size;

    while (true) {                 //проверки на ввод
        cin >> size;
        
        if (cin.peek() == '\n')
        {
            cin.get();
            break;
        }
        else
        {
            cout << "Повторите ввод (ожидается натуральное число):" << endl;
            cin.clear();
            while (cin.get() != '\n') {}
        }
    }

    if (size <= 0)
    {
        cout << "Введено недопустимое значение" << endl;
        return 1;
    }

    if (size >= 2147483647)
    {
        cout << "Введён слишком большой размер массива" << endl;
        return 1;
    }

    int* arr;
    try
    {
        arr = new int[size];
    }
    catch (const bad_alloc& e)
    {
        cout << "Недостаточно доступной оперативной памяти" << endl;
        return 1;
    }

    srand(time(NULL)); 
    for (int i = 0; i < size; ++i)      
    {
        arr[i] = rand() % 200 - 100;
    }

    cout << "Массив, заполненный случайными числами: " << endl;
    for (int i = 0; i < size; ++i)
    {
        cout << arr[i] << " ";
    }
    cout << endl;


    auto start = chrono::high_resolution_clock::now();

    bubblesort(&arr[0], &arr[size]);
 
    auto end = chrono::high_resolution_clock::now();
    chrono::duration<float> duration = end - start;
    cout << "Время работы: " << duration.count() << " s" << endl;
   

    cout << "Массив, отсортированный пузырьком: " << endl;
    for (int i = 0; i < size; ++i)
    {
        cout << arr[i] << " ";
    }
    cout << endl;

    cout << "Введите число элементов, на которое будет увеличен массив: " << endl;
    int size_add;
    int size_new;

    while (true) {                
        cin >> size_add;

        if (cin.peek() == '\n')
        {
            cin.get();
            break;
        }
        else
        {
            cout << "Повторите ввод (ожидается натуральное число):" << endl;
            cin.clear();
            while (cin.get() != '\n') {}
        }
    }

    if (size_add <= 0)
    {
        cout << "Введено недопустимое значение" << endl;
        return 1;
    }

    if (size_add >= 2147483647)
    {
        cout << "Введён слишком большой размер массива" << endl;
        return 1;
    }

    size_new = size + size_add;
    arr = (int*)realloc((void*)arr, size_new * sizeof(int));
   
    if (arr == NULL)
    {
        cout << "Недостаточно доступной оперативной памяти" << endl;
        return 1;
    }

    for (int i = size; i < size_new; ++i)
    {
        arr[i] = rand() % 200 - 100;
    }

    cout << "Массив с новыми элементами: " << endl;
    for (int i = 0; i < size_new; ++i)
    {
        cout << arr[i] << " ";
    }
    cout << endl;


    auto start1 = chrono::high_resolution_clock::now();

    quicksort(&arr[0], &arr[size_new]);

    auto end1 = chrono::high_resolution_clock::now();
    chrono::duration<float> duration1 = end1 - start1;
    cout << "Время работы: " << duration1.count() << " s" << endl;


    cout << "Массив, отсортированный quicksort-ом: " << endl;
    for (int i = 0; i < size_new; ++i)
    {
        cout << arr[i] << " ";
    }
    cout << endl;

    delete[] arr;

    return 0;
}

